# Licensed under the Apache License, Version 2.0 or the MIT License.
# SPDX-License-Identifier: Apache-2.0 OR MIT
# Copyright Tock Contributors 2024.
# This workflow contains all Treadmill-based hardware CI jobs.
#
# Treadmill is a distributed hardware testbed developed within the Tock OS
# project. For more information on Treadmill, have a look at its documentation
# [1] or repository [2].
#
# This workflow is based on the Treadmill GitHub Actions integration guide [3].
# In addition, it features the ability to run multiple Treadmill jobs and
# test-execute stages through GitHub Action's job matrices, and uses a GitHub
# environment to allow deployments with access to secrets for select PRs.
#
# [1]: https://book.treadmill.ci/
# [2]: https://github.com/treadmill-tb/treadmill
# [3]: https://book.treadmill.ci/user-guide/github-actions-integration.html
#
name: treadmill-ci
env:
  TERM: xterm # Makes tput work in actions output
on:
  workflow_call:
    inputs:
      repository-filter:
        required: true
        type: string
      job-environment:
        required: true
        type: string
      tock-hardware-ci-ref:
        required: true
        type: string
      tock-kernel-ref:
        required: true
        type: string
      libtock-c-ref:
        required: true
        type: string
      tests-json:
        required: false
        type: string
        default: '["tests/c_hello.py"]' # Default to single test for backward compatibility
      # New inputs for multi-board tests
      multi-board:
        required: false
        type: string
        default: 'false'
      supervisor-id:
        required: false
        type: string
        default: ''
      board-descriptors:
        required: false
        type: string
        default: ''
jobs:
  test-prepare:
    runs-on: ubuntu-latest
    # Do not run job on forks, as they will not have the correct environment set up
    if: github.repository == inputs.repository-filter
    environment: ${{ inputs.job-environment }}
    outputs:
      tml-job-ids: ${{ steps.treadmill-job-launch.outputs.tml-job-ids }}
      tml-jobs: ${{ steps.treadmill-job-launch.outputs.tml-jobs }}
    steps:
      - uses: actions-rust-lang/setup-rust-toolchain@v1
      - name: Checkout Treadmill repository
        uses: actions/checkout@v4
        with:
          repository: treadmill-tb/treadmill
          # treadmill-tb/treadmill main as of Oct 1, 2024, 3:05 PM EDT
          ref: 'c82f4d7ebddd17f8275ba52139e64e04623f30cb'
          path: treadmill
      - name: Cache Treadmill CLI compilation artifacts
        id: cache-tml-cli
        uses: actions/cache@v4
        with:
          path: treadmill/target
          key: ${{ runner.os }}-tml-cli
      - name: Compile the Treadmill CLI binary
        run: |
          pushd treadmill
          cargo build --package tml-cli
          popd
          echo "$PWD/treadmill/target/debug" >> "$GITHUB_PATH"
      - name: Generate a token to register new just-in-time runners
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.TREADMILL_GH_APP_CLIENT_ID }}
          private-key: ${{ secrets.TREADMILL_GH_APP_PRIVATE_KEY }}
      - name: Create GitHub just-in-time runners and enqueue Treadmill jobs
        id: treadmill-job-launch
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
          TML_API_TOKEN: ${{ secrets.TREADMILL_API_TOKEN }}
          # Currently, all tests run only on hosts attached to an nRF52840DK
          DUT_BOARD: nrf52840dk
          # A Raspberry Pi OS netboot (NBD) image with a GitHub Actions
          # self-hosted runner pre-configured.
          #
          # For the available images see
          # https://book.treadmill.ci/treadmillci-deployment/images.html
          IMAGE_ID: 7222c531071705fcaaf2a82504c3d09c93701d8a307de266fb551294911a1181

          # Limit the supervisors to hosts that are compatible with this
          # image. This is a hack until we introduce "image sets" which define
          # multiple images for various supervisor hosts, but otherwise behave
          # identically:
          HOST_TYPE: nbd-netboot
          HOST_ARCH: arm64
          TESTS_JSON: ${{ inputs.tests-json }}
          # Support for specific supervisor targeting for multi-board tests
          MULTI_BOARD: ${{ inputs.multi-board }}
          SUPERVISOR_ID: ${{ inputs.supervisor-id }}
        run: |
          # When we eventually launch tests on multiple hardware platforms in
          # parallel, we need to supply different SUB_TEST_IDs here:
          SUB_TEST_ID="0"

          # This runner ID uniquely identifies the GitHub Actions runner we're
          # registering and allows us to launch test-execute jobs on this exact
          # runner (connected to the exact board we want to run tests on).
          RUNNER_ID="tml-gh-actions-runner-${GITHUB_REPOSITORY_ID}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${SUB_TEST_ID}"

          # Obtain a new just-in-time runner registration token:
          RUNNER_CONFIG_JSON="$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/runners/generate-jitconfig \
            -f "name=$RUNNER_ID" \
            -F "runner_group_id=1" \
            -f "labels[]=$RUNNER_ID" \
            -f "work_folder=_work")"
          echo "Generated configuration for runner $(echo "$RUNNER_CONFIG_JSON" | jq -r '.runner.name')"

          # Generate a set of job paramters that includes the GitHub runner
          # registration token and a script that shuts down the host once the
          # runner has run through successfully (and created a file indicating
          # successful job completion, /run/github-actions-shutdown):
          TML_JOB_PARAMETERS="{\
            \"gh-actions-runner-encoded-jit-config\": {\
              \"secret\": true, \
              \"value\": \"$(echo "$RUNNER_CONFIG_JSON" | jq -r '.encoded_jit_config')\" \
            }, \
            \"gh-actions-runner-exec-stop-post-sh\": {\
              \"secret\": false, \
              \"value\": \"if [ \\\"\$SERVICE_RESULT\\\" = \\\"success\\\" ] && [ -f /run/github-actions-shutdown ]; then tml-puppet job terminate; fi\" \
            }\
          }"

          echo "Enqueueing treadmill job:"

          # If this is a multi-board test targeting a specific supervisor
          if [ "$MULTI_BOARD" = "true" ] && [ -n "$SUPERVISOR_ID" ]; then
            echo "Attempting to enqueue multi-board job on supervisor: $SUPERVISOR_ID"
            # For supervisor-specific jobs, only use the supervisor tag
            TML_JOB_ID_JSON="$(tml job enqueue \
              "$IMAGE_ID" \
              --tag-config "supervisor:$SUPERVISOR_ID" \
              --parameters "$TML_JOB_PARAMETERS" \
            )" || {
              echo "ERROR: Failed to enqueue job. The supervisor $SUPERVISOR_ID may not be available or properly configured."
              echo "Response: $TML_JOB_ID_JSON"
              exit 1
            }
          else
            # Default job enqueue for single board tests
            TML_JOB_ID_JSON="$(tml job enqueue \
              "$IMAGE_ID" \
              --tag-config "board:$DUT_BOARD;host-type:$HOST_TYPE;host-arch:$HOST_ARCH" \
              --parameters "$TML_JOB_PARAMETERS" \
            )" || {
              echo "ERROR: Failed to enqueue job."
              echo "Response: $TML_JOB_ID_JSON"
              exit 1
            }
          fi

          # Check if we got valid JSON response
          if ! echo "$TML_JOB_ID_JSON" | jq -e . >/dev/null 2>&1; then
            echo "ERROR: Invalid JSON response from tml job enqueue"
            echo "Response: $TML_JOB_ID_JSON"
            exit 1
          fi

          TML_JOB_ID="$(echo "$TML_JOB_ID_JSON" | jq -r .job_id)"
          if [ "$TML_JOB_ID" = "null" ] || [ -z "$TML_JOB_ID" ]; then
            echo "ERROR: Failed to get job_id from response"
            echo "Response: $TML_JOB_ID_JSON"
            exit 1
          fi
          echo "Enqueued Treadmill job with ID $TML_JOB_ID"


          # Pass the job IDs and other configuration data into the outputs of
          # this step, such that we can run test-execute job instances for each
          # Treadmill job we've started:
          TML_JOB_IDS_OUTPUT="[ \"$TML_JOB_ID\" ]"
          echo "Setting tml-job-ids output to ${TML_JOB_IDS_OUTPUT}"
          echo "tml-job-ids=${TML_JOB_IDS_OUTPUT}" >> "$GITHUB_OUTPUT"
          TML_JOBS_OUTPUT="{ \"$TML_JOB_ID\": { \"runner-id\": \"$RUNNER_ID\", \"tests\": $(echo "$TESTS_JSON" | jq -c '.') } }"
          echo "Setting tml-jobs output to ${TML_JOBS_OUTPUT}"
          echo "tml-jobs=${TML_JOBS_OUTPUT}" >> "$GITHUB_OUTPUT"

          # Generate an overview over the scheduled jobs and their respective tests:
          cat <<GITHUB_STEP_SUMMARY >>"$GITHUB_STEP_SUMMARY"
          ## Test Overview
          | Test | Board | Job |
          |------|-------|-----|
          GITHUB_STEP_SUMMARY
          echo "$TESTS_JSON" | jq -r -c '.[]' | while read TEST; do
            BOARD_INFO="$DUT_BOARD"
            if [ "$MULTI_BOARD" = "true" ]; then
              BOARD_INFO="Multiple boards on supervisor $SUPERVISOR_ID"
            fi
            echo "| \`$TEST\` | \`$BOARD_INFO\` | [\`$TML_JOB_ID\`](#tml-job-summary-$TML_JOB_ID) |" >>"$GITHUB_STEP_SUMMARY"
          done
  test-execute:
    needs: test-prepare
    strategy:
      matrix:
        tml-job-id: ${{ fromJSON(needs.test-prepare.outputs.tml-job-ids) }}
    runs-on: ${{ fromJSON(needs.test-prepare.outputs.tml-jobs)[matrix.tml-job-id].runner-id }}
    steps:
      - name: Print Treadmill Job Context and Debug Information
        run: |
          echo "Treadmill job id: ${{ matrix.tml-job-id }}"
          echo "GitHub Actions Runner ID: ${{ fromJSON(needs.test-prepare.outputs.tml-jobs)[matrix.tml-job-id].runner-id }}"
          echo "Host ID: $(cat /run/tml/host-id)"
          echo "===== Parameters: ====="
          ls /run/tml/parameters
          echo "===== User & group configuration: ====="
          echo "whoami: $(whoami)"
          echo "groups: $(groups)"
          echo "===== Network configration: ====="
          ip address
          echo "===== Attached USB & serial console devices: ====="
          lsusb
          ls -lh /dev/ttyAMA* 2>/dev/null || true
          ls -lh /dev/ttyACM* 2>/dev/null || true
          ls -lh /dev/ttyUSB* 2>/dev/null || true
          ls -lh /dev/bus/usb/*/* 2>/dev/null || true
      - name: Disable wget progress output
        run: |
          echo "verbose = off" >> $HOME/.wgetrc
      - uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          # Avoid overwriting the RUSTFLAGS environment variable
          rustflags: ''
      # This is required for the actions/checkout steps to perform a
      # proper git clone that also supports checking out submodules:
      - name: Install git
        run: |
          # TODO: currently, the Netboot NBD targets have no access to their
          # boot parition (e.g., mounted on /boot/firmware) on a Raspberry Pi OS
          # host. This causes certain hooks in response to dpkg / apt commands
          # to fail. Thus we ignore errors in these steps until we figure this
          # part out.
          sudo DEBIAN_FRONTEND=noninteractive apt update || true
          sudo DEBIAN_FRONTEND=noninteractive apt install -y git
      - name: Checkout the Tock Hardware CI scripts
        uses: actions/checkout@v4
        with:
          repository: tock/tock-hardware-ci
          ref: ${{ inputs.tock-hardware-ci-ref }}
      - name: Checkout the Tock kernel repository
        uses: actions/checkout@v4
        with:
          path: hwci/repos/tock
          repository: tock/tock
          ref: ${{ inputs.tock-kernel-ref }}
      - name: Checkout the libtock-c repository
        uses: actions/checkout@v4
        with:
          path: hwci/repos/libtock-c
          repository: tock/libtock-c
          ref: ${{ inputs.libtock-c-ref }}
          fetch-depth: 0
          submodules: false
          persist-credentials: true
      - name: Run setup script
        run: |
          cd ./hwci/
          ./setup.sh
      - name: Run tests
        env:
          JSON_TEST_ARRAY: ${{ toJSON(fromJSON(needs.test-prepare.outputs.tml-jobs)[matrix.tml-job-id].tests) }}
          MULTI_BOARD: ${{ inputs.multi-board }}
          SUPERVISOR_ID: ${{ inputs.supervisor-id }}
          BOARD_DESCRIPTORS: ${{ inputs.board-descriptors }}
        run: |
          # Activate the virtual environment from the hwci directory
          source ./hwci/.venv/bin/activate

          FAILED_TESTS=""

          # Generate a summary of all the tests executed:
          cat <<GITHUB_STEP_SUMMARY >>"$GITHUB_STEP_SUMMARY"
          ### <a id="tml-job-summary-${{ matrix.tml-job-id }}"></a>Tests executed on job ID ${{ matrix.tml-job-id }}

          | Result | Test |
          |--------|------|
          GITHUB_STEP_SUMMARY

          while read TEST; do
          # WHILE ---------->

          # Open a new "group" in the GitHub actions output for this test:
          echo "::group::Test ${TEST}"

          # For markdown links, we want a sanitized test name without special characters
          SANITIZED_TEST_NAME="${TEST//[^[:alnum:]]/_}"

          # Prepare a collapsible section in the test output:
          cat <<STEP_SUMMARY_DETAILS >>"./step-summary-details.txt"
          <details>
          <summary>Test \`$TEST\`</summary>
          ##### <a id="#test-$SANITIZED_TEST_NAME"></a> Test \`$TEST\`

          \`\`\`
          STEP_SUMMARY_DETAILS

          # Run the test script, saving its output:
          echo "===== RUNNING TEST $TEST ====="
          FAIL=0
          set -o pipefail

          # Check if this is a multi-board test with specific board descriptors
          if [ "$MULTI_BOARD" = "true" ] && [ -n "$BOARD_DESCRIPTORS" ]; then
            echo "Running multi-board test with specified board descriptors"
            BOARD_DESC_ARGS="--board-descriptors"
            for DESC in $BOARD_DESCRIPTORS; do
              BOARD_DESC_ARGS+=" $DESC"
            done

            echo "Running from directory: $(pwd)"
            echo "Command: python3 hwci/core/main.py $BOARD_DESC_ARGS --test hwci/$TEST"

            # Run test with multiple board descriptors
            python3 hwci/core/main.py $BOARD_DESC_ARGS --test "hwci/$TEST" 2>&1 | tee ./job-output.txt || FAIL=1

          else
            # For single-board test
            echo "Running single-board test"
            
            # Try to determine which supervisor we're running on from the Host ID file
            HOST_ID=$(cat /run/tml/host-id 2>/dev/null || echo "")
            if [ -n "$HOST_ID" ]; then
              echo "Running on host/supervisor: $HOST_ID"
            fi
            
            # Look for board descriptor based on runtime host ID or provided supervisor ID
            BOARD_DESC_FILE=""
            
            # First priority: Use the host ID we're actually running on
            if [ -n "$HOST_ID" ] && [ -d "board_descriptors/$HOST_ID" ]; then
              echo "Looking for board descriptor in supervisor directory: board_descriptors/$HOST_ID/"
              # Find first board descriptor YAML in the supervisor's directory
              BOARD_DESC_FILE=$(find "board_descriptors/$HOST_ID" -name "board-*.yml" -type f | head -n 1)
              
              if [ -n "$BOARD_DESC_FILE" ]; then
                echo "Found board descriptor for current supervisor: $BOARD_DESC_FILE"
              else
                echo "WARNING: Supervisor directory exists but no board descriptor found"
              fi
            fi
            
            # Second priority: If SUPERVISOR_ID was provided as input but we didn't find descriptor yet
            if [ -z "$BOARD_DESC_FILE" ] && [ -n "$SUPERVISOR_ID" ]; then
              echo "Checking provided SUPERVISOR_ID: $SUPERVISOR_ID"
              # Check if it's a full file path
              if [ -f "$SUPERVISOR_ID" ]; then
                BOARD_DESC_FILE="$SUPERVISOR_ID"
                echo "Using provided board descriptor path: $BOARD_DESC_FILE"
              elif [ -d "board_descriptors/$SUPERVISOR_ID" ]; then
                # It's just the UUID, look for first board descriptor in that directory
                BOARD_DESC_FILE=$(find "board_descriptors/$SUPERVISOR_ID" -name "board-*.yml" -type f | head -n 1)
                if [ -n "$BOARD_DESC_FILE" ]; then
                  echo "Found board descriptor in provided supervisor directory: $BOARD_DESC_FILE"
                fi
              fi
            fi
            
            # Third priority: Fall back to any available board descriptor
            if [ -z "$BOARD_DESC_FILE" ] || [ ! -f "$BOARD_DESC_FILE" ]; then
              echo "WARNING: Could not find supervisor-specific board descriptor"
              echo "Looking for any available nrf52840dk board descriptor..."
              BOARD_DESC_FILE=$(find board_descriptors -name "board-nrf52840dk-*.yml" -type f | head -n 1)
              
              if [ -n "$BOARD_DESC_FILE" ]; then
                echo "Using fallback board descriptor: $BOARD_DESC_FILE"
              fi
            fi
            
            # Last resort: Create a minimal board descriptor
            if [ -z "$BOARD_DESC_FILE" ] || [ ! -f "$BOARD_DESC_FILE" ]; then
              echo "WARNING: No board descriptor found, creating minimal temporary descriptor"
              echo "Note: GPIO tests will not work without proper pin_mappings"
              
              TEMP_DESC_DIR="./temp_board_descriptors"
              mkdir -p "$TEMP_DESC_DIR"
              BOARD_DESC_FILE="$TEMP_DESC_DIR/board-nrf52840dk-default.yml"
              
              echo "model: nrf52840dk" > "$BOARD_DESC_FILE"
              echo "serial_number: ''" >> "$BOARD_DESC_FILE"
              echo "board_module: hwci/boards/nrf52dk.py" >> "$BOARD_DESC_FILE"
              echo "features:" >> "$BOARD_DESC_FILE"
              echo "  ble: true" >> "$BOARD_DESC_FILE"
              echo "  debugger: jlink" >> "$BOARD_DESC_FILE"
              echo "  gpio: false" >> "$BOARD_DESC_FILE"
            fi

            echo "Using board descriptor: $BOARD_DESC_FILE"
            echo "Running from directory: $(pwd)"
            echo "Command: python3 hwci/core/main.py --board-descriptors $BOARD_DESC_FILE --test hwci/$TEST"
            
            # Run test with board descriptor
            python3 hwci/core/main.py --board-descriptors "$BOARD_DESC_FILE" --test "hwci/$TEST" 2>&1 | tee ./job-output.txt || FAIL=1
            
            # Clean up temporary descriptor if we created one
            if [ -d "./temp_board_descriptors" ]; then
              rm -rf "./temp_board_descriptors"
            fi
          fi

          set +o pipefail

          # Insert the result into the markdown table:
          if [ "$FAIL" == "0" ]; then
            echo "| ✅ | \`$TEST\` ([Output](#test-$SANITIZED_TEST_NAME)) |" >>"$GITHUB_STEP_SUMMARY"
          else
            echo "===== Test $TEST failed! ====="
            echo "| ❌ | \`$TEST\` ([Output](#test-$SANITIZED_TEST_NAME)) |" >>"$GITHUB_STEP_SUMMARY"

            # Append this test to the list of failed tests (prefixing
            # it with a comma, if other tests have already failed:
            test -n "${FAILED_TESTS}" && FAILED_TESTS="${FAILED_TESTS}, "
            FAILED_TESTS="${FAILED_TESTS}${TEST}"
          fi

          # Sanitize the output (remove triple backslashes) and copy it into the step summary details:
          cat ./job-output.txt | sed 's/```//g' >>"./step-summary-details.txt"

          # Finalize this section of the test output summary:
          cat <<STEP_SUMMARY_DETAILS >>"./step-summary-details.txt"
          \`\`\`

          </details>

          STEP_SUMMARY_DETAILS

          # Close the "group" in the GitHub actions output:
          echo "::endgroup::"

          # -----------> DONE
          done < <(echo "$JSON_TEST_ARRAY" | jq -r -c '.[]')

          # Finally, add all test output sections to the overall step summary:
          echo "" >>"$GITHUB_STEP_SUMMARY"
          cat "./step-summary-details.txt" >>"$GITHUB_STEP_SUMMARY"

          # Exit with an error if at least one test failed:
          if [ "$FAILED_TESTS" != "" ]; then
            echo "One or more tests failed, exiting with error: $FAILED_TESTS"
            exit 1
          fi
      - name: Request shutdown after successful job completion
        run: |
          sudo touch /run/github-actions-shutdown
      - name: Provide connection information on job failure
        if: failure()
        run: |
          echo "This CI job has failed, we avoid terminating the Treadmill job"
          echo "immediately. It will be active until it reaches its timeout."
          echo ""
          echo "If you added SSH keys to the `job enqueue` command, you can"
          echo "open an interactive session to this host. Connection"
          echo "information is available here:"
          echo "https://book.treadmill.ci/treadmillci-deployment/sites.html"
          echo ""
          echo "TODO: print host / supervisor ID as part of workflow"
          echo "TODO: determine public SSH endpoint automatically and print"
          echo "TODO: allow adding SSH keys to running Treadmill jobs"
