# Licensed under the Apache License, Version 2.0 OR the MIT License.
# SPDX-License-Identifier: Apache-2.0 OR MIT

import logging
import time
import re
from utils.test_helpers import OneshotTest


class VulnerabilityIPC4371Test(OneshotTest):
    def __init__(self):
        super().__init__(
            apps=[
                "tests/memory_high_watermark_vulnerability/server",
                "tests/memory_high_watermark_vulnerability/client",
            ]
        )

    def capture_buffer_contents(self, serial, timeout=3.0):
        """Capture buffer hex contents from serial output"""
        buffer_contents = []
        start_time = time.time()

        # Look for buffer hex dump lines
        while time.time() - start_time < timeout:
            line = serial.readline(timeout=0.5)
            if line:
                if "Buffer contents (hex):" in line:
                    buffer_contents.append(line.strip())
                    # Continue capturing the next lines which are part of the hex dump
                    while True:
                        line = serial.readline(timeout=0.5)
                        if not line or ":" not in line:  # End of hex dump
                            break
                        buffer_contents.append(line.strip())
                    break  # We've captured the entire buffer dump

        return buffer_contents

    def print_buffer_comparison(self, before, after):
        """Print a comparison of buffer contents before and after crash"""
        logging.info("====== BUFFER COMPARISON ======")
        logging.info("BEFORE CRASH:")
        for line in before:
            logging.info(line)

        logging.info("\nAFTER CRASH:")
        for line in after:
            logging.info(line)

        logging.info("==============================")

        # Attempt to highlight differences
        if len(before) > 0 and len(after) > 0:
            # Extract hex values
            before_hex = " ".join(
                [re.sub(r".*?:", "", line).strip() for line in before]
            )
            after_hex = " ".join([re.sub(r".*?:", "", line).strip() for line in after])

            before_bytes = before_hex.split()
            after_bytes = after_hex.split()

            # Count pattern changes
            client_pattern = 0
            kernel_pattern = 0

            for i, b in enumerate(
                before_bytes[: min(len(before_bytes), len(after_bytes))]
            ):
                if b != after_bytes[i]:
                    # Look for patterns suggesting kernel memory
                    if (
                        after_bytes[i] == "00"
                        and i + 1 < len(after_bytes)
                        and after_bytes[i + 1] == "00"
                    ):
                        kernel_pattern += 1
                    # Non-ASCII values often indicate pointers or kernel structures
                    if int(after_bytes[i], 16) > 127:
                        kernel_pattern += 1

            if kernel_pattern > 5:
                logging.info(
                    "ANALYSIS: Buffer after crash shows probable kernel memory patterns"
                )
            else:
                logging.info(
                    "ANALYSIS: Buffer after crash doesn't show clear kernel memory patterns"
                )

    def oneshot_test(self, board):
        gpio = board.gpio
        serial = board.serial

        # Map the LEDs & buttons according to target_spec.yaml
        led_pins = {
            "LED1": gpio.pin("P0.13"),  # First LED for vulnerability indication
        }
        button_pins = {
            "BUTTON1": gpio.pin("P0.11"),  # Button 0: Examine buffer
            "BUTTON2": gpio.pin("P0.12"),  # Button 1: Crash client
        }

        # Configure LED pins as inputs to read their state
        for led in led_pins.values():
            led.set_mode("input")

        # Configure Button pins as outputs
        for button in button_pins.values():
            button.set_mode("output")
            button.write(0)  # Ensure buttons are not pressed at start

        logging.info("Starting Vulnerability IPC #4371 Test")

        # Wait for server to start
        assert serial.expect("Vulnerability Demo Server starting") is not None
        assert serial.expect("Server registered. Waiting for clients") is not None

        # Wait for client to start and connect
        assert serial.expect("Vulnerability Demo Client") is not None
        assert serial.expect("Client: Setup complete") is not None

        # Wait for initial buffer registration
        assert serial.expect("Server: Client registered buffer") is not None

        logging.info("Initial setup complete, both apps running")
        time.sleep(1)

        logging.info("Step 1: Examining buffer before crash")
        # Press button 0 to examine the buffer before crash
        button_pins["BUTTON1"].write(1)
        time.sleep(0.1)
        button_pins["BUTTON1"].write(0)

        # Wait for server to report examining the buffer
        assert serial.expect("Client: Requesting server to examine buffer") is not None
        assert serial.expect("Server: Examining buffer") is not None

        # Capture the buffer contents before crash
        before_buffer = self.capture_buffer_contents(serial)
        logging.info(f"Captured buffer before crash: {len(before_buffer)} lines")

        time.sleep(1)

        logging.info("Step 2: Triggering client crash")
        # Press button 1 to crash the client
        button_pins["BUTTON2"].write(1)
        time.sleep(0.1)
        button_pins["BUTTON2"].write(0)

        # Wait for client crash message
        assert serial.expect("Client: Triggering crash") is not None

        # Wait for client to restart
        assert serial.expect("Vulnerability Demo Client") is not None
        assert serial.expect("(Restart count: 1)") is not None
        assert serial.expect("Client: Setup complete") is not None
        time.sleep(1)

        logging.info("Step 3: Examining buffer after crash")
        # Press button 0 again to examine the buffer after crash
        button_pins["BUTTON1"].write(1)
        time.sleep(0.1)
        button_pins["BUTTON1"].write(0)

        # Wait for server to report examining the buffer
        assert serial.expect("Client: Requesting server to examine buffer") is not None
        assert (
            serial.expect("Server: Examining buffer after client restart") is not None
        )

        # Capture the buffer contents after crash
        after_buffer = self.capture_buffer_contents(serial)
        logging.info(f"Captured buffer after crash: {len(after_buffer)} lines")

        # Print detailed comparison of buffer contents
        self.print_buffer_comparison(before_buffer, after_buffer)

        # Now check the LED state to determine if vulnerability was detected
        time.sleep(2)  # Give time for the check to complete
        led_state = led_pins["LED1"].read()
        led_on = led_state == 0

        # Check if we see a vulnerability result in the serial output
        vuln_detected = (
            serial.expect("!!! VULNERABILITY DETECTED !!!", timeout=0.5) is not None
        )
        fix_working = (
            serial.expect(
                "âœ“ SECURE: Buffer still contains original client data", timeout=0.5
            )
            is not None
        )

        if vuln_detected:
            logging.info("Vulnerability detected in buffer after restart!")
            assert led_on, "LED should be ON when vulnerability is detected"
        elif fix_working:
            logging.info(
                "Fix is working! Buffer still contains original data after restart."
            )
            assert not led_on, "LED should be OFF when fix is working"
        else:
            # If neither message is found, check LED as fallback
            if led_on:
                logging.info("Vulnerability detected (based on LED state)")
            else:
                logging.info("Fix appears to be working (based on LED state)")

        # IMPORTANT: Comment out the assertion below after applying the fix
        # The test expects the vulnerability to exist before fixing it
        assert vuln_detected, "Without fix, vulnerability should be detected"

        # Uncomment the line below after applying the fix to test that it works
        # assert fix_working, "With fix applied, the buffer should still contain original data"


test = VulnerabilityIPC4371Test()
